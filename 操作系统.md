## 进程通信

https://cloud.tencent.com/developer/article/1496658

### 共享内存

共享内存就是映射一段能被其他进程所访问的内存,这段共享内存由一个进程创建,但多个进程都可以访问.共享内存是最快的IPC(进程间通信)方式,**它是针对其它进程间通信方式运行效率低而专门设计的**.它往往与其他通信机制,如信号量,配合使用,来实现进程间的同步与通信. 

访问共享内存区域和访问进程独有的内存区域一样快，并不需要通过系统调用或者其它需要切入内核的过程来完成. 

共享在共享大数据文件时有用，直接在相同进行内存的拷贝，速度快，效率高，需要考虑访问临界资源并发同步

优点：无须复制，快捷，信息量大；

缺点：

​	1）通信是通过将共无法实现享空间缓冲区直接附加到进程的虚拟地址空间中来实现的，因此进程间的读写操作的同步问题；

​	2)利用内存缓冲区直接交换信息，内存的实体存在于计算机中，**只能同一个计算机系统中的诸多进程共享**，不方便网络通信

#### 和其他通信方式的对比

共享内存和消息队列，FIFO，管道传递消息的区别：

消息队列，FIFO，管道的消息传递方式一般为

> 1：服务器得到输入 
>
> 2：通过管道，消息队列写入数据，通常需要从进程拷贝到内核。 
>
> 3：客户从内核拷贝到进程 
>
> 4：然后再从进程中拷贝到输出文件 

上述过程通常要经过4次拷贝，才能完成文件的传递。 

共享内存只需要

> 1:从输入文件到共享内存区
>
> 2:从共享内存区输出到文件

**上述过程不涉及到内核的拷贝，所以花的时间较少。**

#### 和动态链接库的对比

https://www.cnblogs.com/tongyishu/p/11722004.html

多个程序虽然可以共享同一个动态链接库中的相同代码，但**每一个进程都为动态链接库使用的全部数据分配了自己的地址空间**。而**共享内存是代码和数据均被多个程序所共享**。动态链接库只是实现了代码的复用，对于数据，各个程序要自己保存。共享内存用于进程间通信，主要用于数据的内存共享。这也从侧面反映出**动态链接库并不能用于实现进程之间通信**。

动态链接库相当于是一个大家都可以访问的文件, 在需要使用的时候动态加载, 每个进程使用它的进程都会对它加载和建立映射. 





### 管道

在[类Unix](https://zh.wikipedia.org/wiki/Unix-like)[操作系统](https://zh.wikipedia.org/wiki/操作系统)（以及一些其他借用了这个设计的操作系统，如Windows）中，**管道**（英语：Pipeline）是一系列将[标准输入输出](https://zh.wikipedia.org/wiki/标准流)链接起来的[进程](https://zh.wikipedia.org/wiki/进程)，其中每一个进程的[输出](https://zh.wikipedia.org/wiki/Stdout)被直接作为下一个进程的[输入](https://zh.wikipedia.org/wiki/Stdin)。 每一个链接都由匿名管道实现[[来源请求\]](https://zh.wikipedia.org/wiki/Wikipedia:列明来源)。管道中的组成元素也被称作[过滤程序](https://zh.wikipedia.org/w/index.php?title=过滤程序&action=edit&redlink=1)。

**管道的通信介质是文件**，这种文件通常称为管道文件，两个进程利用管道文件进行通信时，一个进程为写进程，另一个进程为读进程。写进程通过写端（发送端）往管道文件中写入信息；读进程通过读端（接收端）从管道文件中读取信息。两个进程协调不断地进行写、读，便会构成双方通过管道传递信息的流水线。

#### 匿名管道

匿名管道是半双工的，数据只能单向通信；需要双方通信时，需要建立起两个管道；只能用于父子进程或者兄弟进程之间（具有亲缘关系的进程）。

1) 由pipe系统调用，管道由父进程建立
2) 单工通信的
3) 在关系进程中进行(父进程和子进程、同一个父进程的两个子进程之间)
4) 管道位于内核空间，其实是一块缓存

比如命令 `ls -l | less` 在shell上执行, 开始我理解不是说只能在父子进程或兄弟进程之间通信吗? 为什么这两个进程不相关啊? **但其实他们是兄弟进程, 因为他们都是shell进程fork出来的** 

**优点：简单方便；缺点：1）局限于单向通信2）只能创建在它的进程以及其有亲缘关系的进程之间;3）缓冲区有限；**  

#### 有名管道(FIFO)

不同于匿名管道之处在于它提供一个路径名与之关联，以FIFO的文件形式存在于文件系统中。这样，即使与FIFO的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过FIFO相互通信（能够访问该路径的进程以及FIFO的创建进程之间），因此，通过FIFO不相关的进程也能交换数据。值得注意的是，FIFO严格遵循先进先出（first in first out），对管道及FIFO的读总是从开始处返回数据，对它们的写则把数据添加到末尾。

**优点：可以实现任意关系的进程间的通信；缺点：1）长期存于系统中，使用不当容易出错；2）缓冲区有限** 





### 信号量





### 消息队列

使用`ipcs -q`查看

```
➜  my-interview git:(master) ✗ ipcs -q

------ Message Queues --------
key        msqid      owner      perms      used-bytes   messages

➜  my-interview git:(master) ✗ ipcs   

------ Message Queues --------
key        msqid      owner      perms      used-bytes   messages

------ Shared Memory Segments --------
key        shmid      owner      perms      bytes      nattch     status

------ Semaphore Arrays --------
key        semid      owner      perms      nsems
```

https://www.jianshu.com/p/7598e5ed5200

MQ 传递的是消息，消息即是我们需要在进程间传递的数据。MQ 采用链表来实现消息队列，该链表是由系统内核维护，系统中可能有很多的 MQ，每个 MQ 用**消息队列描述符**（消息队列 ID：qid）来区分，qid 是唯一的，用来区分不同的 MQ。在进行进程间通信时，一个进程将消息加到 MQ 尾端，另一个进程从消息队列中取消息（**不一定以先进先出来取消息，也可以按照消息类型字段取消息**），这样就实现了进程间的通信。如下 MQ 的模型：

![img](assets/4613385-83d5d13247fbf4a0.webp)





### Unix Domain Socket

socket进程间通信. 实现了使用socket的同主机下的进程间通信

https://blog.csdn.net/Roland_Sun/article/details/50266565





## 线程

### 信号量

### 条件变量

### 互斥锁

### 管程

### 协程

### 生产者消费者

### 读者写者

### 死锁

### 哲学家就餐问题





## 内存

虚拟地址空间





## CPU



### CPU调度



### 多核CPU



### 抢占式和非抢占式

抢占式: 允许将逻辑上可继续运行的在运行过程暂停的调度方式   可防止单一进程长时间独占CPU   系统开销大（降低途径：硬件实现进程切换，或扩充主存以贮存大部分程序）

非抢占式: 让进程运行直到结束或阻塞的调度方式

https://blog.csdn.net/uniquewonderq/article/details/48803087

Linux抢占式调度: https://juejin.im/post/5ce10ddd6fb9a07ebe74907f

高优先级获得的虚拟运行时间更多:

> 虚拟运行时间 vruntime += 实际运行时间 delta_exec * NICE_0_LOAD/ 权重(优先级)

在操作系统中维护了一个红黑树，红黑树就是一颗平衡二叉树，也就是说红黑树上面挂了好多进程，最左边的进程就是运行时间最少的进程，所有操作系统在，选取下一个进程就会选取这个红黑树上最左侧的进程。

![img](assets/16acf1e8ed9606e7)

Go协程是抢占式调度

> 引入抢占式调度，会对最初的设计产生比较大的影响，Go还只是引入了一些很初级的抢占，并没有像操作系统调度那么复杂，没有对goroutine分时间片，设置优先级等。
>
> 只有长时间阻塞于系统调用，或者运行了较长时间才会被抢占。runtime会在后台有一个检测线程，它会检测这些情况，并通知goroutine执行调度。
>
> 目前并没有直接在后台的检测线程中做处理调度器相关逻辑，只是相当于给goroutine加了一个“标记”，然后在它进入函数时才会触发调度。这么做应该是出于对现有代码的修改最小的考虑。

比如下面这个例子, 设置核心数为1那么第一个协程在不阻塞的情况下不会被调度(抢占). 会导致无法进入主协程, 然后一直死循环. 

```go
package main

import (
	"fmt"
	"runtime"
	"time"
)

func main() {
	// 设置CPU核心数为 1
	runtime.GOMAXPROCS(1)
	go func() {
		i := 0
		for {
			i += 1
			// 如果不阻塞, 那么设置成了单个核心的go程序将不会被切换协程
			// 会一直执行这个协程, 不会抢占, 所以后面的协程和主协程都不会被调度
			// time.Sleep(time.Second*2)
		}
	}()
	go func() {
		fmt.Println("hello, go")
	}()
	time.Sleep(time.Second*5)
}
```





### Linux 进程调度

Linux内核调度分析（进程调度）: https://cloud.tencent.com/developer/article/1027448

公平调度算法CFS

> 现在我们来看一个简单的例子，假设我们的系统只有两个进程在运行，一个是文本编辑器（I/O消耗型），另一个是视频解码器（处理器消耗型）。
>
> 理想的情况下，文本编辑器应该得到更多的处理器时间，至少当它需要处理器时，处理器应该立刻被分配给它（这样才能完成用户的交互），这也就意味着当文本编辑器被唤醒的时候，它应该抢占视频解码程序。
>
> 按照普通的情况，OS应该分配给文本编辑器更大的优先级和更多的时间片，但在Linux中，这两个进程都是普通进程，他们具有相同的nice值，因此它们将得到相同的处理器使用比（50%）。
>
> 但实际的运行过程中会发生什么呢？CFS将能够注意到，文本编辑器使用的处理器时间比分配给它的要少得多（因为大多时间在等待I/O），这种情况下，要实现所有进程“公平”地分享处理器，就会让文本编辑器在需要运行时立刻抢占视频解码器（每次都是如此）。

如何确定程序的优先级?

nice值如何确定?

CFS原理: https://www.jianshu.com/p/673c9e4817a8

权重由nice值确定，具体的，权重跟进程nice值之间有一一对应的关系，可以通过全局数组prio_to_weight来转换，nice值越大，权重越低。

**新创建进程的vruntime**

> 假如新进程的vruntime初值为0的话，比老进程的值小很多，那么它在相当长的时间内都会保持抢占CPU的优势，老进程就要饿死了，这显然是不公平的。**CFS是这样做的：**每个CPU的运行队列cfs_rq都维护一个min_vruntime字段，记录该运行队列中所有进程的vruntime最小值，新进程的初始vruntime值就以它所在运行队列的min_vruntime为基础来设置，与老进程保持在合理的差距范围内。

**休眠进程的vruntime一直保持不变吗？**

>  如果休眠进程的 vruntime 保持不变，而其他运行进程的 vruntime 一直在推进，那么等到休眠进程终于唤醒的时候，它的vruntime比别人小很多，会使它获得长时间抢占CPU的优势，其他进程就要饿死了。这显然是另一种形式的不公平。**CFS是这样做的：**在休眠进程被唤醒时重新设置vruntime值，以min_vruntime值为基础，给予一定的补偿，但不能补偿太多。

假设有两个进程，它们的vruntime初值都是一样的，第一个进程只要一运行，它的vruntime马上就比第二个进程更大了，那么它的CPU会立即被第二个进程抢占吗？**CFS是这样做的：**为了避免过于短暂的进程切换造成太大的消耗，CFS设定了进程占用CPU的最小时间值，sched_min_granularity_ns，正在CPU上运行的进程如果不足这个时间是不可以被调离CPU的。

**进程从一个CPU迁移到另一个CPU上的时候vruntime会不会变？**

当进程从一个CPU的运行队列中出来 (dequeue_entity) 的时候， 它的vruntime要减去队列的min_vruntime值；

而当进程加入另一个CPU的运行队列 ( enqueue_entiry) 时，它的vruntime要加上该队列的min_vruntime值。

