### 为什么map用红黑树而不是AVL树?

红黑树看红书上的讲解.

https://www.zhihu.com/question/20545708/answer/58717264

1. 如果插入一个node引起了树的不平衡，AVL和RB-Tree都是最多只需要2次旋转操作，即两者都是O(1)；但是在删除node引起树的不平衡时，最坏情况下，AVL需要维护从被删node到root这条路径上所有node的平衡性，因此需要旋转的量级O(logN)，而RB-Tree最多只需3次旋转，只需要O(1)的复杂度。

2. 其次，AVL的结构相较RB-Tree来说更为平衡，在插入和删除node更容易引起Tree的unbalance，因此在大量数据需要插入或者删除时，AVL需要rebalance的频率会更高。因此，RB-Tree在需要大量插入和删除node的场景下，效率更高。自然，由于AVL高度平衡，因此AVL的search效率更高。

3. map的实现只是折衷了两者在search、insert以及delete下的效率。总体来说，RB-tree的统计性能是高于AVL的。

一篇不错的AVL树讲解: https://zhuanlan.zhihu.com/p/34899732

在线AVL可视化: https://www.cs.usfca.edu/~galles/visualization/AVLtree.html





### 最大堆

C++模板类代码实现

```cpp
#include <algorithm>
#include <iostream>
#include <vector>
using namespace std;

template <class T>
class MaxHeap {
   public:
	MaxHeap();
	~MaxHeap();

   public:
	// stl标准API
	T top();
	void push(T val);
	T pop();
	bool empty();

   private:
	// 用数组来保存二叉堆
	vector<T> heap;
	int size;

   private:
	// 元素下沉
	void sink(int top);
	// 元素上升
	void swim(int down);
};

template <class T>
inline MaxHeap<T>::MaxHeap() {
	heap.push_back(-1);
	size = 0;
}

template <class T>
inline MaxHeap<T>::~MaxHeap() {
	heap.clear();
}

template <class T>
inline T MaxHeap<T>::top() {
	return this->heap[1];
}

template <class T>
inline void MaxHeap<T>::push(T val) {
	heap.push_back(val);
	size += 1;
	swim(size);
}

template <class T>
inline bool MaxHeap<T>::empty() {
	return size == 0;
}

template <class T>
inline T MaxHeap<T>::pop() {
	int popVal = heap[1];
	swap(heap[1], heap[size]);
	size -= 1;
	sink(1);
	return popVal;
}

template <class T>
inline void MaxHeap<T>::sink(int top) {
	if (top >= size)
		return;
	int lTop = top * 2, rTop = top * 2 + 1;
	if (rTop <= size) {
		// 左子树和右子树都在范围内
		if (heap[lTop] > heap[top] && heap[lTop] >= heap[rTop]) {
			swap(heap[lTop], heap[top]);
			sink(lTop);
		} else if (heap[rTop] > heap[top] && heap[lTop] < heap[rTop]) {
			swap(heap[rTop], heap[top]);
			sink(rTop);
		}
	} else if (lTop <= size && heap[top] <= heap[lTop]) {
		// 左子树可以交换
		swap(heap[lTop], heap[top]);
		sink(lTop);
	}
	return;
}

template <class T>
inline void MaxHeap<T>::swim(int down) {
	int parent = down / 2;
	if (parent >= 1 && heap[down] > heap[parent]) {
		swap(heap[down], heap[parent]);
		swim(parent);
	}
	return;
}

int main() {
	auto ptr = new MaxHeap<double>();
	for (int i = 0; i < 10; i++) {
		ptr->push((i * i + 17) % 11 + 0.01);
	}
}
```



### 斐波那契堆

好文：https://www.cnblogs.com/skywang12345/p/3659060.html





### STL之vector

这篇文章给出了一些比较详细的介绍: https://blog.csdn.net/u012658346/article/details/50725933

vector使用三个指针来表示位置

```
protected:
    pointer _Myfirst;   // pointer to beginning of array
    pointer _Mylast;    // pointer to current end of sequence
    pointer _Myend; // pointer to end of array
```



![这里写图片描述](assets/20160223191226316)

#### 存储空间再分配问题

size表示vector中已有元素的个数，容量表示vector最多可存储的元素的个数；为了降低二次分配时的成本，vector实际配置的大小可能比客户需求的更大一些，以备将来扩充，这就是容量的概念。即capacity>=size，当等于时，容器此时已满，若再要加入新的元素时，就要**重新进行内存分配**，**整个vector的数据都要移动到新内存。二次分配成本较高，在实际操作时，应尽量预留一定空间，避免二次分配。** 

二次分配的移动次数不会超过2*n次.



#### vector是在堆上还是栈上?

这个知乎回答 https://www.zhihu.com/question/36773826/answer/68943177 这样说

> vector本身并不一定占用动态内存。vector只是管理了一片动态内存。
> vector vs用栈上的vector管理一片动态内存。
> new vector用动态内存里的一个vector管理另一片动态内存。

类似于指针, 指针指向一个new的值, 这部分是在堆的内存空间. 但是这个指针本身是在栈上的. vector也是类似, vector管理了一段动态内存(堆), 但一个普通vector对象是在栈上的, 它管理的内存是堆上的动态内存. 

```cpp
#include <bits/stdc++.h>

using namespace std;

int main() {
	vector<int> vec;
	cout << (&vec) << endl; // 栈

	int b = 1;
	cout << &b << endl; // 栈

	int* a = new int;
	cout << a << endl;  // 堆
	cout << &a << endl;  // 栈

	vector<int>* vec2 = new vector<int>();
	cout << vec2 << endl;  // 堆
	cout << &vec2 << endl;  // 栈
}
```

结果

```
0x61fd20
0x61fd1c
0x666550
0x61fd10
0x666570
0x61fd08
0x666590
0x61fd00
0x2531c90
```



* erase删除的复杂度为O(n), 同insert

* vector中的元素是连续的





### STL之set

* set使用红黑树实现(调用红黑树的接口)

    ![image-20200422101807979](assets/image-20200422101807979.png)

* set的值(也就是键)是不可以更改的

    ![image-20200422101639891](assets/image-20200422101639891.png)

    如果尝试更改, 会报错(只读)

    ```
    setTest.cpp: In function 'int main()':
    setTest.cpp:10:7: error: assignment of read-only reference 's'
       s = 1;
    ```

* set使用RB-tree的 insert_unique(), 而multiset 是Yoon insert_equal, 从而允许同值得存在

    ![image-20200422101945657](assets/image-20200422101945657.png)



### STL之map

* map使用红黑树实现

    ![image-20200422102245070](assets/image-20200422102245070.png)

* map按键排序

* 不可以修改map的键

    ![image-20200422102221828](assets/image-20200422102221828.png)

* map的键值对结构

    ![image-20200422102148605](assets/image-20200422102148605.png)

    ![image-20200422102201043](assets/image-20200422102201043.png)

    


### 斐波那契堆



