

# 数据结构





### 红黑树

#### 红黑树是什么



#### 红黑树的性质



#### 红黑树的API



#### 红黑树应用场景

可参考这个知乎回答

AVL树，红黑树，B树，B+树，Trie树都分别应用在哪些现实场景中？ - 九夏的回答 - 知乎 https://www.zhihu.com/question/30527705/answer/52750388

红黑树是一种平衡搜索树, 可以用来动态排序, 因此在这类场景下都可以用红黑树, 比如

* STL中map, set, multi_set等是基于红黑树的
* Linux的CFS(公平调度算法)用红黑树来维护进程的优先级(虚拟运行时)
* epoll(io多路复用)在内核中的实现，用红黑树管理事件(详情看https://blog.csdn.net/daaikuaichuan/article/details/83862311)
* nginx中，用红黑树管理timer等



### B+树



### 为什么map用红黑树而不是AVL树?

红黑树看红书上的讲解. 

https://www.zhihu.com/question/20545708/answer/58717264

1. 如果插入一个node引起了树的不平衡，AVL和RB-Tree都是最多只需要2次旋转操作，即两者都是O(1)；但是在删除node引起树的不平衡时，最坏情况下，AVL需要维护从被删node到root这条路径上所有node的平衡性，因此需要旋转的量级O(logN)，而RB-Tree最多只需3次旋转，只需要O(1)的复杂度。

2. 其次，AVL的结构相较RB-Tree来说更为平衡，在插入和删除node更容易引起Tree的unbalance，因此在大量数据需要插入或者删除时，AVL需要rebalance的频率会更高。因此，RB-Tree在需要大量插入和删除node的场景下，效率更高。自然，由于AVL高度平衡，因此AVL的search效率更高。

3. map的实现只是折衷了两者在search、insert以及delete下的效率。总体来说，RB-tree的统计性能是高于AVL的。

一篇不错的AVL树讲解: https://zhuanlan.zhihu.com/p/34899732

在线AVL可视化: https://www.cs.usfca.edu/~galles/visualization/AVLtree.html





### 最大堆

C++模板类代码实现

```cpp
#include <algorithm>
#include <iostream>
#include <vector>
using namespace std;

template <class T>
class MaxHeap {
   public:
	MaxHeap();
	~MaxHeap();

   public:
	// stl标准API
	T top();
	void push(T val);
	T pop();
	bool empty();

   private:
	// 用数组来保存二叉堆
	vector<T> heap;
	int size;

   private:
	// 元素下沉
	void sink(int top);
	// 元素上升
	void swim(int down);
};

template <class T>
inline MaxHeap<T>::MaxHeap() {
	heap.push_back(-1);
	size = 0;
}

template <class T>
inline MaxHeap<T>::~MaxHeap() {
	heap.clear();
}

template <class T>
inline T MaxHeap<T>::top() {
	return this->heap[1];
}

template <class T>
inline void MaxHeap<T>::push(T val) {
	heap.push_back(val);
	size += 1;
	swim(size);
}

template <class T>
inline bool MaxHeap<T>::empty() {
	return size == 0;
}

template <class T>
inline T MaxHeap<T>::pop() {
	int popVal = heap[1];
	swap(heap[1], heap[size]);
	size -= 1;
	sink(1);
	return popVal;
}

template <class T>
inline void MaxHeap<T>::sink(int top) {
	if (top >= size)
		return;
	int lTop = top * 2, rTop = top * 2 + 1;
	if (rTop <= size) {
		// 左子树和右子树都在范围内
		if (heap[lTop] > heap[top] && heap[lTop] >= heap[rTop]) {
			swap(heap[lTop], heap[top]);
			sink(lTop);
		} else if (heap[rTop] > heap[top] && heap[lTop] < heap[rTop]) {
			swap(heap[rTop], heap[top]);
			sink(rTop);
		}
	} else if (lTop <= size && heap[top] <= heap[lTop]) {
		// 左子树可以交换
		swap(heap[lTop], heap[top]);
		sink(lTop);
	}
	return;
}

template <class T>
inline void MaxHeap<T>::swim(int down) {
	int parent = down / 2;
	if (parent >= 1 && heap[down] > heap[parent]) {
		swap(heap[down], heap[parent]);
		swim(parent);
	}
	return;
}

int main() {
	auto ptr = new MaxHeap<double>();
	for (int i = 0; i < 10; i++) {
		ptr->push((i * i + 17) % 11 + 0.01);
	}
}
```



### 斐波那契堆

好文：https://www.cnblogs.com/skywang12345/p/3659060.html





### STL之vector

这篇文章给出了一些比较详细的介绍: https://blog.csdn.net/u012658346/article/details/50725933

vector使用三个指针来表示位置

```
protected:
    pointer _Myfirst;   // pointer to beginning of array
    pointer _Mylast;    // pointer to current end of sequence
    pointer _Myend; // pointer to end of array
```



![这里写图片描述](assets/20160223191226316)

#### 存储空间再分配问题

size表示vector中已有元素的个数，容量表示vector最多可存储的元素的个数；为了降低二次分配时的成本，vector实际配置的大小可能比客户需求的更大一些，以备将来扩充，这就是容量的概念。即capacity>=size，当等于时，容器此时已满，若再要加入新的元素时，就要**重新进行内存分配**，**整个vector的数据都要移动到新内存。二次分配成本较高，在实际操作时，应尽量预留一定空间，避免二次分配。** 

二次分配的移动次数不会超过2*n次.



#### vector是在堆上还是栈上?

这个知乎回答 https://www.zhihu.com/question/36773826/answer/68943177 这样说

> vector本身并不一定占用动态内存。vector只是管理了一片动态内存。
> vector vs用栈上的vector管理一片动态内存。
> new vector用动态内存里的一个vector管理另一片动态内存。

类似于指针, 指针指向一个new的值, 这部分是在堆的内存空间. 但是这个指针本身是在栈上的. vector也是类似, vector管理了一段动态内存(堆), 但一个普通vector对象是在栈上的, 它管理的内存是堆上的动态内存. 

```cpp
#include <bits/stdc++.h>

using namespace std;

int main() {
	vector<int> vec;
	cout << (&vec) << endl; // 栈

	int b = 1;
	cout << &b << endl; // 栈

	int* a = new int;
	cout << a << endl;  // 堆
	cout << &a << endl;  // 栈

	vector<int>* vec2 = new vector<int>();
	cout << vec2 << endl;  // 堆
	cout << &vec2 << endl;  // 栈
}
```

结果

```
0x61fd20
0x61fd1c
0x666550
0x61fd10
0x666570
0x61fd08
0x666590
0x61fd00
0x2531c90
```



* erase删除的复杂度为O(n), 同insert

* vector中的元素是连续的





### STL之set

* set使用红黑树实现(调用红黑树的接口)

    ![image-20200422101807979](assets/image-20200422101807979.png)

* set的值(也就是键)是不可以更改的

    ![image-20200422101639891](assets/image-20200422101639891.png)

    如果尝试更改, 会报错(只读)

    ```
    setTest.cpp: In function 'int main()':
    setTest.cpp:10:7: error: assignment of read-only reference 's'
       s = 1;
    ```

* set使用RB-tree的 insert_unique(), 而multiset 是Yoon insert_equal, 从而允许同值得存在

    ![image-20200422101945657](assets/image-20200422101945657.png)



### STL之map

* map使用红黑树实现

    ![image-20200422102245070](assets/image-20200422102245070.png)

* map按键排序

* 不可以修改map的键

    ![image-20200422102221828](assets/image-20200422102221828.png)

* map的键值对结构

    ![image-20200422102148605](assets/image-20200422102148605.png)

    ![image-20200422102201043](assets/image-20200422102201043.png)


C++中map的键可以使用map类型, 因为两个同类型的map是可以比较的(应该是比最小的键的值).

但是unordered_map的键是不可以





### 跳跃表(跳表)

一种基于链表的有序集合

漫画跳跃表: https://zhuanlan.zhihu.com/p/53975333

通过给链表建立多级索引来实现快速查找, 删除, 插入

![img](assets/v2-55915f6a2bcca4138eb6f9281309f003_720w.jpg)

那么插入了一个元素之后, 如何更新索引呢?

用抛硬币的方法!

以一定概率(比如50%)决定需不需要在上一层建立索引, 如果建立了, 然后再抛硬币确定再上一层需不需要建立索引. 虽然无法达到完全的均匀索引, 但是整体上是均匀的.

redis的**Sorted-set**就是基于跳跃表的改进实现

#### skiplist与平衡树、哈希表的比较

来源: https://blog.csdn.net/hebtu666/article/details/102556064

* skiplist和各种平衡树（如AVL、红黑树等）的元素是有序排列的，而哈希表不是有序的。因此，在哈希表上只能做单个key的查找，不适宜做范围查找。所谓范围查找，指的是查找那些大小在指定的两个值之间的所有节点。

* **在做范围查找的时候，平衡树比skiplist操作要复杂。**在平衡树上，我们找到指定范围的小值之后，还需要以中序遍历的顺序继续寻找其它不超过大值的节点。如果不对平衡树进行一定的改造，这里的中序遍历并不容易实现。而在skiplist上进行范围查找就非常简单，只需要在找到小值之后，对第1层链表进行若干步的遍历就可以实现。
    平衡树的插入和删除操作可能引发子树的调整，逻辑复杂，而skiplist的插入和删除只需要修改相邻节点的指针，操作简单又快速。

* **从内存占用上来说，skiplist比平衡树更灵活一些。**一般来说，平衡树每个节点包含2个指针（分别指向左右子树），而skiplist每个节点包含的指针数目平均为1/(1-p)，具体取决于参数p的大小。如果像Redis里的实现一样，取p=1/4，那么平均每个节点包含1.33个指针，比平衡树更有优势。
    查找单个key，skiplist和平衡树的时间复杂度都为O(log n)，大体相当；而哈希表在保持较低的哈希值冲突概率的前提下，查找时间复杂度接近O(1)，性能更高一些。所以我们平常使用的各种Map或dictionary结构，大都是基于哈希表实现的。

* **从算法实现难度上来比较，skiplist比平衡树要简单得多**。

#### Redis中的skiplist和经典有何不同

https://blog.csdn.net/hebtu666/article/details/102556064

分数(score)允许重复，即skiplist的key允许重复。这在最开始介绍的经典skiplist中是不允许的。
在比较时，不仅比较分数（相当于skiplist的key），还比较数据本身。在Redis的skiplist实现中，数据本身的内容唯一标识这份数据，而不是由key来唯一标识。另外，当多个元素分数相同的时候，还需要根据数据内容来进字典排序。
第1层链表不是一个单向链表，而是一个双向链表。这是为了方便以倒序方式获取一个范围内的元素。
在skiplist中可以很方便地计算出每个元素的排名(rank)。