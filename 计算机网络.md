### http和https

https://www.zhihu.com/question/19577317

http的默认端口为80, 而https默认端口为443.

http是HTTP协议运行在TCP之上。所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。

**https是HTTP运行在SSL/TLS之上，SSL/TLS运行在TCP之上**。所有传输的内容都经过加密，加密采用对称加密，但**对称加密的密钥用服务器方的证书进行了非对称加密**。此外客户端可以验证服务器端的身份，如果配置了客户端验证，服务器方也可以验证客户端的身份。

SSL（Security Sockets Layer，安全套接层）

SSL3.0后更名为TLS

这篇文章讲的非常好, 非常清楚: https://juejin.im/entry/58d7635e5c497d0057fae036

一个例子

> 这套证书其实就是一对公钥和私钥，如果对公钥和私钥不太理解，可以想象成一把钥匙和一个锁头，只是全世界只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。



### http版本: 1和2





### 如何实现登陆状态





### 爬虫与反爬的对抗





### 线程池

https://juejin.im/post/5c8896be5188257ec828072f

https://blog.csdn.net/hanghangaidoudou/article/details/81628166

优点:

1、线程是稀缺资源，使用线程池可以减少创建和销毁线程的次数，每个工作线程都可以重复使用。

2、可以根据系统的承受能力，调整线程池中工作线程的数量，防止因为消耗过多内存导致服务器崩溃。

3、解耦作用；线程的创建于执行完全分开，方便维护。

**线程消耗的资源:**

1. 内存资源(线程多了这个内存就会很大)
2. CPU调度的上下文切换资源
3. 线程创建和消亡的开销
4. 对锁/IO设备的竞争

多线程的代价: https://www.cnblogs.com/ktgu/p/3529144.html





### 五种IO模型

**转载自: https://juejin.im/post/5bd32b84f265da0ac962e7c9**

网络数据的IO过程:

- 等待数据从网络送达，到达后被复制到内核缓冲区
- 把数据从内核缓冲区复制到应用程序缓冲区

1. 阻塞式IO

    使用系统调用，并一直阻塞直到内核将数据准备好，之后再由内核缓冲区复制到用户态，在等待内核准备的这段时间什么也干不了

    ![img](assets/166c5502f8bcffc9)

    

2. 非阻塞式IO

    内核在没有准备好数据的时候会返回错误码，而调用程序不会休眠，而是不断轮询询问内核数据是否准备好

    非阻塞式IO的轮询会耗费大量cpu，通常在专门提供某一功能的系统中才会使用。通过为套接字的描述符属性设置非阻塞式，可使用该功能

![](assets/166c553d1d575e5f)

3. IO多路复用

    类似与非阻塞，只不过轮询不是由用户线程去执行，而是由内核去轮询，内核监听程序监听到数据准备好后，调用内核函数复制数据到用户态

    下图中select这个系统调用，充当代理类的角色，不断轮询注册到它这里的所有需要IO的文件描述符，有结果时，把结果告诉被代理的recvfrom函数，它本尊再亲自出马去拿数据

    IO多路复用至少有两次系统调用，如果只有一个代理对象，性能上是不如前面的IO模型的，但是由于它可以同时监听很多套接字，所以性能比前两者高

    ![img](assets/166c5615fdf084fd)

    多路复用包括：

    - select：线性扫描所有监听的文件描述符，不管他们是不是活跃的。有最大数量限制（32位系统1024，64位系统2048）
    - poll：同select，不过数据结构不同，需要分配一个pollfd结构数组，维护在内核中。它没有大小限制，不过需要很多复制操作
    - epoll：用于代替poll和select，没有大小限制。使用一个文件描述符管理多个文件描述符，使用红黑树存储。**同时用事件驱动代替了轮询。epoll_ctl中注册的文件描述符在事件触发的时候会通过回调机制激活该文件描述符。epoll_wait便会收到通知**。最后，**epoll还采用了mmap虚拟内存映射技术减少用户态和内核态数据传输的开销**

4. 信号驱动式IO

    - 使用信号，内核在数据准备就绪时通过信号来进行通知
    - 首先开启信号驱动io套接字，并使用sigaction系统调用来安装信号处理程序，内核直接返回，不会阻塞用户态
    - 数据准备好时，内核会发送SIGIO信号，收到信号后开始进行io操作

    ![img](assets/166c569138a05186)

5. 异步IO

    异步IO依赖信号处理程序来进行通知

    不过异步IO与前面IO模型不同的是：前面的都是数据准备阶段的阻塞与非阻塞，异步IO模型通知的是IO操作已经完成，而不是数据准备完成

    异步IO才是真正的非阻塞，主进程只负责做自己的事情，等IO操作完成(数据成功从内核缓存区复制到应用程序缓冲区)时通过回调函数对数据进行处理

    unix中异步io函数以aio_或lio_打头

    ![img](assets/166c56cf32b82d81)

#### 对比

- 前面四种IO模型的主要区别在第一阶段，他们第二阶段是一样的：数据从内核缓冲区复制到调用者缓冲区期间都被阻塞住！
- 前面四种IO都是同步IO：IO操作导致请求进程阻塞，直到IO操作完成
- 异步IO：**IO操作不导致请求进程阻塞**(完全不导致！)

![img](assets/166c578ad18a1d40)



#### 同步IO和异步IO的区别

https://juejin.im/post/5c725dbe51882575e37ef9ed

**两者的区别就在于synchronous IO做”IO operation”的时候会将process阻塞。**按照这个定义，之前所述的blocking IO，non-blocking IO，IO multiplexing都属于synchronous IO。注意到non-blocking IO会一直轮询(polling)，这个过程是没有阻塞的，但是recvfrom阶段blocking IO,non-blocking IO和IO multiplexing都是阻塞的。 而asynchronous IO则不一样，当进程发起IO 操作之后，就直接返回再也不理睬了，直到kernel发送一个信号，告诉进程说IO完成。在这整个过程中，进程完全没有被block。



### IO多路复用

转载自: https://juejin.im/post/5c725dbe51882575e37ef9ed

#### select

select本质是通过设置或检查存放fd标志位的数据结构来进行下一步处理。缺点是：

1. 单个进程可监视的fd数量被限制，即能监听端口的大小有限。一般来说和系统内存有关，具体数目可以cat /proc/sys/fs/file-max察看。32位默认是1024个，64位默认为2048个

    不过我电脑上是这么多个。。。

    ![image-20200417103903366](assets/image-20200417103903366.png)

2. 对socket进行扫描时是线性扫描，即采用轮询方法，效率低。当套接字比较多的时候，每次select()都要遍历FD_SETSIZE个socket来完成调度，不管socket是否活跃都遍历一遍。会浪费很多CPU时间。如果能给套接字注册某个回调函数，当他们活跃时，自动完成相关操作，就避免了轮询，这正是epoll与kqueue做的

3. 需要维护一个用来存放大量fd的数据结构，会使得用户空间和内核空间在传递该结构时复制开销大

#### poll

poll本质和select相同，将用户传入的数据拷贝到内核空间，然后查询每个fd对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或主动超时，被唤醒后又要再次遍历fd。它没有最大连接数的限制，原因是它是基于链表来存储的，但缺点是：

1. 大量的fd的数组被整体复制到用户态和内核空间之间，不管有无意义。
2. poll还有一个特点“水平触发”，如果报告了fd后，没有被处理，那么下次poll时再次报告该ffd。

#### epoll

epoll支持水平触发和边缘触发，最大特点在于边缘触发，只告诉哪些fd刚刚变为就绪态，并且只通知一次。还有一特点是，epoll使用“事件”的就绪通知方式，通过epoll_ctl注册fd，一但该fd就绪，内核就会采用类似callback的回调机制来激活该fd，epoll_wait便可以收到通知。epoll的优点：

1. 没有最大并发连接的限制。
2. 效率提升，只有活跃可用的FD才会调用callback函数。
3. 内存拷贝，利用mmap()文件映射内存加速与内核空间的消息传递。

#### select、poll、epoll区别总结：

|        |    支持一个进程打开连接数     |                  IO效率                  |                   消息传递方式                   |
| :----: | :---------------------------: | :--------------------------------------: | :----------------------------------------------: |
| select |  32位机器1024个，64位2048个   |                 IO效率低                 | 内核需要将消息传递到用户空间，都需要内核拷贝动作 |
|  poll  |   无限制，原因基于链表存储    |                 IO效率低                 | 内核需要将消息传递到用户空间，都需要内核拷贝动作 |
| epoll  | 有上限，但很大，2G内存20W左右 | 只有活跃的socket才调用callback，IO效率高 |     **通过内核与用户空间共享一块内存来实现**     |







### epool原理

